[
  {
    "name": "rep",
    "verbalName": "Règle de répétition",
    "verbalDescription": "Si A était dans les prémisses, alors on peut répéter A dans la déduction. (Cliquez sur la prémisse à répéter.)",
    "arrayUtilization": "",
    "instruction": "Cliquez directement sur une prémisse, sans passer par cette fenêtre.",
    "expectedArguments": [],
    "available": "yes"
  },
  {
    "name": "reit",
    "verbalName": "Règle de réitération",
    "verbalDescription": "Si A a été posé dans la déduction, alors on peut réitérer A dans la déduction. Il est impossible de réitérer l'inférence A si elle provient d'une hypothèse terminée. (Cliquez sur l'inférence à réitérer.)",
    "arrayUtilization": [["A", "|B", "|A reit"]],
    "instruction": "Cliquez sur l'inférence à réitérer dans l'hypothèse en cours.",
    "expectedArguments": [],
    "available": "yes"
  },
  {
    "name": "hyp",
    "verbalName": "Hypothèse",
    "verbalDescription": "A tout moment d'une déduction, on peut faire une hypothèse A. On peut sortir de cette hypothèse en la validant (ce qui permet d'introduire le conditionnel entre le contenu de l'hypothèse, et la dernière inférence, B, avant la sortie de l'hypothèse : inférer A⊃B) ou en la réfutant si l'on arrive à une contradiction (ce qui permet de nier le contenu de l'hypothèse : inférer ~A).\nDe plus, il est toujours possible de créer une hypothèse au sein d'une autre hypothèse. On peut aussi y répéter des prémisses ou y réitérer des inférences, si l'on veut les y utiliser.",
    "arrayUtilization": [
      ["|A hyp", "(...)", "|B", "A⊃B ⊃i"],
      ["|A hyp", "(...)", "|B", "|~B", "A ~i"]
    ],
    "instruction": "Formulez une hypothèse pour ensuite tenter de la valider ou de la réfuter.",
    "expectedArguments": ["hyp"],
    "available": "yes"
  },
  {
    "name": "ex falso",
    "verbalName": "Règle ex falso, ou principe d'explosion",
    "verbalDescription": "A partir du faux, on peut conclure ce que l'on veut. Par exemple lorsque deux prémisses contenaient à elles seules une contradiction.",
    "arrayUtilization": "",
    "instruction": "(Pas encore codée)",
    "expectedArguments": [],
    "available": "maybenever"
  },
  {
    "name": "~i",
    "verbalName": "Règle d'introduction de la négation (modus tollens)",
    "verbalDescription": "Si l'on a prouvé que A était faux (en montrant une contradiction dans une hypothèse A) on peut inférer ~A.",
    "arrayUtilization": [["hyp A", "contradiction", "~A ~i"]],
    "instruction": "Créez une hypothèse A, et pendant qu'elle est en cours, et qu'au moins deux inférence B et ~B la suivent, confirmez cette règle pour réfuter l'hypothèse, en inférant ~A.",
    "expectedArguments": ["A", "B", "~B"],
    "available": "yes",
    "binomial": "i"
  },
  {
    "name": "~~e",
    "verbalName": "Règle d'élimination de la double négation, dérivée de ~i",
    "verbalDescription": "Si l'on prouve que ~A est faux, on peut inférer ~~A (ce qui a exactement le même sens que A dans la logique classique). Et sur la base de ~~A, on peut inférer A.",
    "arrayUtilization": "",
    "instruction": "Cliquez sur ~~A, pour inférer A.",
    "expectedArguments": ["~~A"],
    "available": "yes",
    "binomial": "e",
    "notaBene": "Il est facile de trouver des exemples montrant que ~~A ne dit pas forcément la même que A, ou que ~~~~A. Les doubles négation ne sont pas toujours simplement redondantes, et c'est là un important exemple des limites de la logique des propositions. [à développer]"
  },
  {
    "name": "∧i",
    "verbalName": "Règle d'introduction de la conjonction",
    "verbalDescription": "Si A et B ont été posés, on peut inférer A∧B.",
    "arrayUtilization": [["A", "B", "A∧B ∧i"]],
    "instruction": "Cliquez sur A, puis B, pour inférer A∧B.",
    "expectedArguments": ["A", "B"],
    "available": "yes",
    "binomial": "i"
  },
  {
    "name": "∧e",
    "verbalName": "Règle d'élimination de la conjonction",
    "verbalDescription": "Si A∧B a été posé, on peut inférer A et/ou B.",
    "arrayUtilization": [["A∧B", "A ∧e"], ["A∧B", "B ∧e"]],
    "instruction": "Cliquez sur A∧B, puis sélectionnez A ou B, pour l'inférer.",
    "expectedArguments": ["A∧B"],
    "available": "yes",
    "binomial": "e"
  },
  {
    "name": "∨i",
    "verbalName": "Règle d'introduction de la disjonction inclusive",
    "verbalDescription": "Si A a été posé, on peut inférer A∨B, quel que soit B.",
    "arrayUtilization": [
      ["A", "A∨B ∨i"],
      ["B", "A∨B ∨i"],
      ["A", "B", "A∨B ∨i"]
    ],
    "instruction": "Cliquez sur A, puis décidez arbitrairement de B, pour inférer A∨B.",
    "expectedArguments": ["A"],
    "available": "yes",
    "binomial": "i"
  },
  {
    "name": "∨e",
    "verbalName": "Règle d'élimination de la disjonction inclusive",
    "verbalDescription": "Si A∨B a été posé, et que depuis l'hypothèse A, C a été trouvé, et que depuis l'hypothèse B, C a été trouvé, alors on peut inférer C. Y compris si C est identique à A ou B.",
    "arrayUtilization": [
      ["A∨B", "|A hyp", "|C", "|B hyp", "|C", "C 1, 2-3, 4-5, ∨e"],
      ["A∨B", "|A hyp", "|A", "|B hyp", "|A", "A 1, 2-3, 4-5, ∨e"]
    ],
    "instruction": "Cliquez sur A∨B, puis créez une hypothèse A depuis cette fenêtre, puis cliquez sur une inférence C (qui peut être semblable à A ou B) dans cette hypothèse, refermez-la depuis cette fenêtre, ouvrez une hypothèse B depuis cette fenêtre, puis cliquez sur une inférence C dans cette hypothèse, et enfin refermez-la. Validez alors la règle pour inférer C.",
    "expectedArguments": ["A∨B", "C |A", "C |B"],
    "available": "yes",
    "binomial": "e"
  },
  {
    "name": "⊻i",
    "verbalName": "Règle d'introduction de la disjonction exclusive",
    "verbalDescription": "Si A a été posé comme vrai, et que B a été posé comme faux (ou inversement) on peut inférer A⊻B.",
    "arrayUtilization": [["A", "~B", "A⊻B ⊻i"]],
    "instruction": "(Pas encore codée)",
    "expectedArguments": [],
    "available": "maybenever",
    "binomial": "i"
  },
  {
    "name": "⊻e",
    "verbalName": "Règle d'élimination de la disjonction exclusive",
    "verbalDescription": "Si A⊻B a été posé, [il faut trouver lequel des deux est vrai et c'est pas évident wesh [à développer]].",
    "arrayUtilization": "",
    "instruction": "(Pas encore codée)",
    "expectedArguments": [],
    "available": "maybenever",
    "binomial": "e"
  },
  {
    "name": "⊃i",
    "verbalName": "Règle d'introduction du conditionnel",
    "verbalDescription": "Si l'on fait l'hypothèse que A et que l'on arrive à B, on peut valider l'hypothèse et inférer A⊃B (si A alors B). Cette règle signifie que si l'on part d'une hypothèse et que l'on peut arriver à un certain résultat, alors il y a un lien de nécessité généralisable entre les deux. (A noter que A⊃B signifie exactement la même chose que ~(A∧~B).)",
    "arrayUtilization": [["|A hyp", "|B", "A⊃B ⊃i"]],
    "instruction": "Créez une hypothèse A, et pendant qu'elle est en cours, et qu'au moins une inférence B la suit, confirmez cette règle pour valider l'hypothèse, en inférant A⊃B.",
    "expectedArguments": ["A", "B"],
    "available": "yes",
    "binomial": "i"
  },
  {
    "name": "⊃e",
    "verbalName": "Règle d'élimination du conditionnel (modus ponens)",
    "verbalDescription": "Si l'on a posé A, et que l'on a posé A⊃B, on peut poser B isolément.",
    "arrayUtilization": "",
    "instruction": "Cliquez sur A, puis A⊃B, pour inférer B.",
    "expectedArguments": ["A", "A⊃B"],
    "available": "yes",
    "binomial": "e"
  },
  {
    "name": "⊂i",
    "verbalName": "Règle d'introduction de la contraposée du conditionnel",
    "verbalDescription": "",
    "arrayUtilization": "",
    "instruction": "(Pas encore codée)",
    "expectedArguments": [],
    "available": "soon",
    "binomial": "i"
  },
  {
    "name": "⊂e",
    "verbalName": "Règle d'élimination de la contraposée du conditionnel (modus tollens)",
    "verbalDescription": "",
    "arrayUtilization": "",
    "instruction": "(Pas encore codée)",
    "expectedArguments": [],
    "available": "soon",
    "binomial": "e"
  },
  {
    "name": "≡i",
    "verbalName": "Règle d'introduction du biconditionnel",
    "verbalDescription": "Si l'on a posé A⊃B et B⊃A, on peut poser A≡B.",
    "arrayUtilization": "",
    "instruction": "Cliquez sur A⊃B, puis B⊃A, pour inférer A≡B.",
    "expectedArguments": ["A⊃B", "B⊃A"],
    "available": "yes",
    "binomial": "i"
  },
  {
    "name": "≡e",
    "verbalName": "Règle d'élimination du biconditionnel",
    "verbalDescription": "Si A≡B a été posé, A⊃B et B⊃A peuvent être inférés.",
    "arrayUtilization": "",
    "instruction": "Cliquez sur A≡B, puis sélectionnez A⊃B ou B⊃A, pour l'inférer.",
    "expectedArguments": ["A≡B"],
    "available": "yes",
    "binomial": "e"
  },
  {
    "name": "|i",
    "verbalName": "Règle d'introduction de l'incompatibilité",
    "verbalDescription": "",
    "arrayUtilization": "",
    "instruction": "(Pas encore codée)",
    "expectedArguments": [],
    "available": "soon",
    "binomial": "i"
  },
  {
    "name": "|e",
    "verbalName": "Règle d'élimination de l'incompatibilité (ou modus ponendo tollens)",
    "verbalDescription": "Si l'on a A|B, que l'on a A, on peut inférer que ~B.",
    "arrayUtilization": [["A|B", "A", "~B |e"], ["A|B", "~A", "B |e"]],
    "instruction": "(Pas encore codée)",
    "expectedArguments": [],
    "available": "soon",
    "binomial": "e"
  },
  {
    "name": "□i",
    "verbalName": "Règle d'introduction de la nécessité",
    "verbalDescription": "Si l'on arrive à p depuis une hypothèse vide, on peut inférer □p.",
    "arrayUtilization": "",
    "instruction": "(Pas encore codée)",
    "expectedArguments": [],
    "available": "later",
    "binomial": "i"
  },
  {
    "name": "□e",
    "verbalName": "Règle d'élimination de la nécessité",
    "verbalDescription": "Si l'on a posé □p, alors on peut inférer que p.",
    "arrayUtilization": "",
    "instruction": "(Pas encore codée)",
    "expectedArguments": [],
    "available": "later",
    "binomial": "e"
  },
  {
    "name": "◊i",
    "verbalName": "Règle d'introduction de la possibilité",
    "verbalDescription": "",
    "arrayUtilization": "",
    "instruction": "(Pas encore codée)",
    "expectedArguments": [],
    "available": "maybenever",
    "binomial": "i"
  },
  {
    "name": "◊e",
    "verbalName": "Règle d'élimination de la possibilité",
    "verbalDescription": "",
    "arrayUtilization": "",
    "instruction": "(Pas encore codée)",
    "expectedArguments": [],
    "available": "maybenever",
    "binomial": "e"
  },
  {
    "name": "∀i",
    "verbalName": "Règle d'introduction du quantificateur universel",
    "verbalDescription": "",
    "arrayUtilization": "",
    "available": "maybenever",
    "binomial": "i"
  },
  {
    "name": "∀e",
    "verbalName": "Règle d'élimination du quantificateur universel",
    "verbalDescription": "",
    "arrayUtilization": "",
    "instruction": "(Pas encore codée)",
    "expectedArguments": [],
    "available": "maybenever",
    "binomial": "e"
  },
  {
    "name": "Ǝi",
    "verbalName": "Règle d'introduction de quantificateur existentiel",
    "verbalDescription": "",
    "arrayUtilization": "",
    "instruction": "(Pas encore codée)",
    "expectedArguments": [],
    "available": "maybenever",
    "binomial": "i"
  },
  {
    "name": "Ǝe",
    "verbalName": "Règle d'élimination de quantificateur universel",
    "verbalDescription": "",
    "arrayUtilization": "",
    "instruction": "(Pas encore codée)",
    "expectedArguments": [],
    "available": "maybenever",
    "binomial": "e"
  },
  {
    "name": "=i",
    "verbalName": "Règle d'introduction de l'identité",
    "verbalDescription": "Il est toujours possible de dire A = A, lorsque l'on a A. Pour A=B, il faut [à développer]",
    "arrayUtilization": "",
    "instruction": "(Pas encore codée)",
    "expectedArguments": [],
    "available": "maybenever",
    "binomial": "i"
  },
  {
    "name": "=e",
    "verbalName": "Règle d'élimination de l'identité",
    "verbalDescription": "",
    "arrayUtilization": "",
    "instruction": "(Pas encore codée)",
    "expectedArguments": [],
    "available": "maybenever",
    "binomial": "e"
  }
]
